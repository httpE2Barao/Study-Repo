<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Princípios de design - OO</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f5f5f5;
      margin: 0;
      padding: 0;
    }
    .container {
      max-width: 800px;
      margin: 40px auto;
      background-color: #fff;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 0 6px rgba(0,0,0,0.1);
    }
    h1 {
      color: #333;
      text-align: center;
    }
    h2 {
      font-size: 20px;
      margin-top: 20px;
      color: #222;
    }
    p {
      font-size: 16px;
      line-height: 1.6;
      color: #444;
      margin: 8px 0;
    }
    pre {
      background-color: #00000;
      color: #fffff;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
      font-family: Consolas, monospace;
      margin: 8px 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Princípios de design - OO</h1>
    <div>
      <h2>🏗 Princípios de Design em Engenharia de Software</h2><p>Criar software de qualidade envolve mais do que apenas escrever código funcional. Aplicando princípios sólidos de design, conseguimos desenvolver sistemas mais flexíveis, escaláveis e fáceis de manter.</p><h2>🎯 Principais objetivos:</h2><h2>✅ Criar sistemas modulares e organizados.</h2><h2>✅ Facilitar manutenção e evolução.</h2><h2>✅ Reduzir erros e dependências desnecessárias.</h2><h2>🔗 1. Acoplamento</h2><h2>📌 O que é acoplamento?</h2><p>O acoplamento mede o grau de dependência entre módulos ou classes de um sistema.</p><p>🔸 Alto acoplamento → Fortes dependências entre módulos, dificultando modificações.</p><p>🔹 Baixo acoplamento → Módulos independentes, facilitando mudanças e manutenção.</p><h2>💡 Exemplo Prático</h2><h2>📌 Sistema de Pedidos Online</h2><h2>❌ Alto Acoplamento:</h2><p>A classe Pedido acessa diretamente a classe Cliente, conhecendo sua estrutura interna.</p><h2>✔️ Baixo Acoplamento:</h2><p>A classe Pedido recebe um Cliente como parâmetro (injeção de dependência), sem acessar detalhes internos.</p><p>🟢 Benefícios do Baixo Acoplamento</p><h2>✅ Facilita manutenção e refatoração.</h2><h2>✅ Reduz impacto de mudanças em um módulo.</h2><h2>✅ Aumenta a testabilidade do sistema.</h2><h2>🎯 2. Coesão</h2><h2>📌 O que é Coesão?</h2><p>A coesão mede o quão bem os elementos de um módulo ou classe estão relacionados.</p><p>🔸 Baixa coesão → Classe com muitas responsabilidades diferentes.</p><p>🔹 Alta coesão → Classe bem definida, focada em uma única responsabilidade.</p><h2>💡 Exemplo Prático</h2><h2>📌 Classe Círculo</h2><p>✔️ Alta coesão: Métodos calcularÁrea(), calcularCircunferência() e desenhar().</p><p>❌ Baixa coesão: Além dos métodos acima, a classe também salva arquivos e lida com manipulação de strings, fugindo de seu propósito.</p><h2>🛠 Impactos no design:</h2><h2>✅ Alta coesão melhora legibilidade e manutenção.</h2><p>❌ Baixa coesão pode tornar o código difícil de entender e modificar.</p><h2>🏗 3. Decomposição</h2><h2>📌 O que é Decomposição?</h2><p>A decomposição divide um sistema complexo em módulos menores e gerenciáveis, cada um com uma responsabilidade bem definida.</p><h2>💡 Exemplo: Sistema de Loja Online</h2><h2>📦 Pedido</h2><h2>👤 Cliente</h2><h2>🛒 Carrinho de Compras</h2><h2>💳 Pagamento</h2><p>🟢 Vantagens da Decomposição</p><h2>✅ Organização: Código modular e bem estruturado.</h2><h2>✅ Facilidade na localização de erros.</h2><p>✅ Reutilização: Módulos podem ser reaproveitados em outros projetos.</p><h2>🎭 4. Generalização</h2><h2>📌 O que é Generalização?</h2><p>A generalização agrupa características comuns de várias classes em uma classe mais genérica.</p><h2>💡 Exemplo: Classes de Animais</h2><p>📌 Animal → Superclasse com atributos como nome, idade e métodos comer() e dormir().</p><p>📌 Cachorro e Gato → Subclasses, herdando Animal, mas adicionando comportamentos específicos (latir(), mear()).</p><h2>🔄 Generalização vs. Herança</h2><h2>🔹 Generalização → Abstrai características comuns.</h2><p>🔸 Herança → Permite que classes reutilizem código de uma superclasse.</p><p>🟢 Benefícios da Generalização:</p><h2>✅ Reduz redundância no código.</h2><h2>✅ Simplifica o design do sistema.</h2><h2>✅ Facilita a expansão e manutenção.</h2><h2>📌 Considerações Finais</h2><p>🔹 Acoplamento baixo → Mais flexibilidade para mudanças.</p><p>🔹 Alta coesão → Classes bem definidas e fáceis de entender.</p><p>🔹 Decomposição bem planejada → Código modular e escalável.</p><p>🔹 Generalização → Reutilização eficiente de código.</p><p>🎯 Objetivo final: Criar sistemas mais organizados, robustos e de fácil manutenção!</p><h2>📚 Referências Bibliográficas</h2><p>📖 ASCENCIO, A. F. G.; CAMPOS, E. A. V. de. Fundamentos da programação de computadores. Pearson, 2012.</p><p>📖 SOMMERVILLE, I. Engenharia de Software. Pearson, 2019.</p><p>📖 GALLOTTI, G. M. A. Arquitetura de Software. Pearson, 2017.</p><p>📖 MEDEIROS, E. Desenvolvendo software com UML 2.0. Pearson, 2004.</p><h2>🎥 Conteúdo Bônus</h2><h2>📌 Assista ao vídeo:</h2><p>🎬 "Melhores Práticas no Design de Software" – DevMedia no YouTube.</p><h2>🔗 Acesse aqui</h2><h2>🛠 Dicas para Organizar este Conteúdo no Notion</h2><h2>💡 Melhore sua experiência de estudo!</h2><p>📌 Adicione um índice interativo no topo usando Table of Contents.</p><h2>📌 Use destaques e cores para facilitar a leitura.</h2><p>📌 Insira diagramas UML para representar relações entre classes.</p><p>📌 Crie uma seção de exemplos práticos com código em Python ou Java.</p>
    </div>
  </div>
  <script>
    console.log("Página carregada com sucesso!");
  </script>
</body>
</html>